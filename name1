import asyncio
import threading
from concurrent.futures import ThreadPoolExecutor
from playwright.async_api import async_playwright
import nest_asyncio


def sync_print(text):
    with MUTEX:
        print(text)


def start(name, user, wait_time, meetingcode, passcode):
    sync_print(f"{name} started!")

    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True, args=['--use-fake-device-for-media-stream', '--use-fake-ui-for-media-stream'])
        context = browser.new_context(permissions=['microphone'])
        page = context.new_page()
        page.goto(f'https://zoom.us/wc/join/{meetingcode}', timeout=200000)

        try:
            page.click('//button[@id="onetrust-accept-btn-handler"]')
        except:
            pass

        try:
            page.click('//button[@id="wc_agree1"]')
        except:
            pass

        page.wait_for_selector('input[type="text"]', timeout=200000)
        page.fill('input[type="text"]', user)
        page.fill('input[type="password"]', passcode)
        join_button = page.wait_for_selector('button.preview-join-button')
        join_button.click()

      try:
            query = '//button[text()="Join Audio by Computer"]'
           
            mic_button_locator = await page.wait_for_selector(query, timeout=370000)
            await asyncio.sleep(10)
            await mic_button_locator.evaluate_handle('node => node.click()')
            print(f"{name} mic aayenge.")
        except Exception as e:
            print(f"{name} mic nahe aayenge. ", )

        except Exception as e:
            print(e)
            sync_print(f"{name} mic nhi aayenge.")

        sync_print(f"{name} sleep for {wait_time} seconds ...")
        time.sleep(wait_time)
        sync_print(f"{name} ended!")

        browser.close()


def main():
    sec = 90
    wait_time = sec * 60
    workers = []

    names = [
 "Md islam", "Lalit", "Manohar Patil", "Rohit", "Rahul Malhotra", "Pragati durge",
    "SouravÂ ", "Bhaskar Jyoti", "Manoj Gaikwad", "pritmaverma"
    ]

    for i in range(number):
        try:
            user = names[i % len(names)]  # Cycle through the names
        except IndexError:
            break
        wk = threading.Thread(target=start, args=(
            f'[Thread{i}]', user, wait_time, meetingcode, passcode))
        workers.append(wk)

    for wk in workers:
        wk.start()

    for wk in workers:
        wk.join()


if __name__ == '__main__':
    number = int(input("Enter number of Users: "))
    meetingcode = input("Enter meeting code (No Space): ")
    passcode = input("Enter Password (No Space): ")

    main()
